#!/usr/bin/env python3

from itertools import groupby
import re
import sys

FILE_HEADER = """/* This file is automatically generated from xkbcommon-keysyms.h */

/**
 * SECTION:input_keysyms
 * @short_description: Key Symbols
 * @title: Key Symbols
 * @section_id: input_keysyms
 * @include: grx-3.0.h
 *
 * This is a list of the key symbols used by GRX. (They are the same as X11.)
 */
"""

GRX_KEY_DOC = """ *
 * Key symbols.
"""

# These were deprecated already when GRX3 was started, so we skip them.
IGNORE = (
    'XKB_KEY_quoteright',
    'XKB_KEY_quoteright',
    'XKB_KEY_quoteleft',
    'XKB_KEY_Eth',
    'XKB_KEY_Thorn',
    'XKB_KEY_kappa',
    'XKB_KEY_kana_middledot',
    'XKB_KEY_kana_tu',
    'XKB_KEY_kana_TI',
    'XKB_KEY_kana_TU',
    'XKB_KEY_kana_HU',
    'XKB_KEY_Arabic_heh',
    'XKB_KEY_Ukranian_je',
    'XKB_KEY_Ukranian_i',
    'XKB_KEY_Ukranian_yi',
    'XKB_KEY_Serbian_je',
    'XKB_KEY_Serbian_lje',
    'XKB_KEY_Serbian_nje',
    'XKB_KEY_Serbian_dze',
    'XKB_KEY_Ukranian_JE',
    'XKB_KEY_Ukranian_I',
    'XKB_KEY_Ukranian_YI',
    'XKB_KEY_Serbian_JE',
    'XKB_KEY_Serbian_LJE',
    'XKB_KEY_Serbian_NJE',
    'XKB_KEY_Serbian_DZE',
    'XKB_KEY_hebrew_beth',
    'XKB_KEY_hebrew_gimmel',
    'XKB_KEY_hebrew_daleth',
    'XKB_KEY_hebrew_zayin',
    'XKB_KEY_hebrew_het',
    'XKB_KEY_hebrew_teth',
    'XKB_KEY_hebrew_samekh',
    'XKB_KEY_hebrew_finalzadi',
    'XKB_KEY_hebrew_zadi',
    'XKB_KEY_hebrew_kuf',
    'XKB_KEY_hebrew_taf',
)

infile = sys.argv[1]
outfile = sys.argv[2]

with open(infile) as f:
    lines = f.readlines()

skips = []
defs = []

# parse the code to extract important information so we can rearrange it later

for i, l in enumerate(lines):
    m = re.match(r'^#define\s+XKB_KEY_.*', l)
    if m:
        m2 = re.match(r'#define\s+(\w+)\s+(\w+)', m.string)
        ident = m2.group(1).replace('XKB_', 'GRX_')
        if ident in IGNORE:
            skips.append(i)
            continue
        # insert an '_' between camelCase words before making it upper case
        ucase = re.sub(r'(?=[^_])([a-z0-9])([A-Z])', r'\1_\2', ident).upper()
        value = m2.group(2)
        m3 = re.match(r'.*/\*\s*(.*?)\s*\*/', m.string)
        comment = m3 and m3.group(1)
        defs.append({
            'line': i,
            'identifier': ident,
            'ucase': ucase,
            'value': value,
            'comment': comment,
        })

# xkbcommon-keysyms.h uses upper and lower case to differentiate identifiers.
# However, GObject introspection expects enums to not be case-sensitive. So
# we make all identifiers upper case  and inject a UCASE_, LCASE_. or TCASE_
# (upper, lower, or title) for cases where there is a conflict.

defs.sort(key=lambda d: d['ucase'])
for key, val_iter in groupby(defs, lambda d: d['ucase']):
    values = [v for v in val_iter]
    values.sort(key=lambda v: v['identifier'])
    l = len(values)
    if l == 1:
        values[0]['identifier'] = values[0]['ucase']
    elif l == 2:
        id0 = values[0]['identifier']
        id1 = values[1]['identifier']
        i = 0
        while id0[i] == id1[i]:
            i += 1
        if id0[i].isupper() and values[1]['identifier'][i].islower():
            u0 = values[0]['ucase']
            u1 = values[1]['ucase']
            values[0]['identifier'] = u0[:i] + 'UCASE_' + u0[i:]
            values[1]['identifier'] = u1[:i] + 'LCASE_' + u1[i:]
        else:
            raise Exception("Unhandled case (2), %s ?? %s" % (id0, id1))
    elif l == 3:
        id0 = values[0]['identifier']
        id1 = values[1]['identifier']
        id2 = values[2]['identifier']
        i = 0
        while id0[i] == id1[i] == id2[i]:
            i += 1
        j = i + 1
        while id0[j] == id1[j] == id2[j]:
            j += 1
        if (id0[i].isupper() and id0[j].isupper() and
                id1[i].isupper() and id1[j].islower() and
                id2[i].islower() and id2[j].islower()):
            u0 = values[0]['ucase']
            u1 = values[1]['ucase']
            u2 = values[2]['ucase']
            values[0]['identifier'] = u0[:i] + 'UCASE_' + u0[i:]
            values[1]['identifier'] = u1[:i] + 'TCASE_' + u1[i:]
            values[2]['identifier'] = u2[:i] + 'LCASE_' + u2[i:]
        else:
            raise Exception("Unhandled case (3), %s ?? %s ?? %s" %
                            (id0, id1, id2))
    else:
        raise Exception('Unhandled case (%d), %s' %
                        (l, [v['identifier'] for v in values]))

# fix identifiers that start with a digit after the 'GRX_KEY_' prefix
for d in defs:
    member = d['identifier'][8:]
    if member.startswith('3270'):
        # prefix 3270 with 'T' for 'terminal'
        d['identifier'] = d['identifier'][:8] + 'T' + member
    elif re.match(r'^\d', member):
        # prefix anything else starting with a digit with 'D' for 'digit'
        d['identifier'] = d['identifier'][:8] + 'D' + member

# Now modify the file based on our fixups...

for i in skips:
    lines[i] = lines[i].replace('#define', '    //')

for d in defs:
    lines[d['line']] = '    %s\t= %s, /* %s */\n' % (
        d['identifier'], d['value'], d['comment'])

with open(outfile, 'w') as f:
    for l in lines:
        l = l.replace('XKBCOMMON', 'GRX')
        if l.startswith('#endif'):
            f.write('} GrxKey;\n')
            f.write('\n')
        f.write(l)
        if l.startswith('#define _GRX_KEYSYMS_H'):
            f.write('\n')
            f.write(FILE_HEADER)
            f.write('\n')
            f.write('/**\n')
            f.write(' * GrxKey:\n')
            for d in sorted(defs, key=lambda i: i['identifier']):
                ident = d['identifier']
                comment = d['comment'] or ident[7:].title().replace('_', ' ')
                # if the comment is surrounded with (), gtkdoc will think it
                # is a directive, so we need to strip it off
                if comment.startswith('('):
                    comment = comment[1:-1]
                f.write(' * @%s: %s\n' % (ident, comment))
            f.write(GRX_KEY_DOC)
            f.write(' */\n')
            f.write('typedef enum\n')
            f.write('{\n')
